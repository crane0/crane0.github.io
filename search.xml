<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>reduce的使用和实现</title>
    <url>/2020/05/08/reduce%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>这是 reduce</p>
<p>typeof undefined 和直接判断 undefined 的区别，主要体现在如果变量未定义，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> crane === <span class="string">'undefined'</span> <span class="comment">// true</span></span><br><span class="line">crane === <span class="literal">undefined</span> <span class="comment">// 报错 crane is not defined</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript 核心</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>JavaScript 核心</tag>
      </tags>
  </entry>
  <entry>
    <title>合并代码时要注意的问题</title>
    <url>/2021/10/25/%E5%90%88%E5%B9%B6%E4%BB%A3%E7%A0%81%E6%97%B6%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>介绍合并代码时要注意的问题，git rebase 能做什么？</p>
<a id="more"></a>

<h1 id="1，commit为什么要一条线"><a href="#1，commit为什么要一条线" class="headerlink" title="1，commit为什么要一条线"></a>1，commit为什么要一条线</h1><p>因为在一条线上后，如果遇到了bug 或是其他暂时解决不了的问题时，方便进行<strong>版本回退</strong>。</p>
<h1 id="2，如何做"><a href="#2，如何做" class="headerlink" title="2，如何做"></a>2，如何做</h1><p><strong>工作区 –add–&gt; 暂存区 –commit–&gt; 版本库</strong></p>
<h2 id="2-1，使用-stash"><a href="#2-1，使用-stash" class="headerlink" title="2.1，使用 stash"></a>2.1，使用 stash</h2><blockquote>
<p>这种方式比较适合：多人是在<strong>同一分支</strong>上做修改。</p>
</blockquote>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1，先将本地的修改添加到<strong>暂存区</strong>，并且放到垃圾箱中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git stash</span><br></pre></td></tr></table></figure>
<p>2，拉取远程代码后，本地代码就是最新的了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>3，将垃圾箱中的代码取出，此时有冲突解决就可以了。</p>
<blockquote>
<p>注意刚刚放到垃圾箱中的，现在是被当做<strong>新的代码</strong>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><p>1，如果代码add后，又commit到了版本库，就不能使用 stash 这种方法了。</p>
<p>解决办法：先回退到 add 后的状态，也就是撤销刚刚的 commit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure>
<p>再按照上述步骤执行即可。</p>
<h2 id="2-2，使用-rebase"><a href="#2-2，使用-rebase" class="headerlink" title="2.2，使用 rebase"></a>2.2，使用 rebase</h2><h3 id="情况1，同一条分支多人开发"><a href="#情况1，同一条分支多人开发" class="headerlink" title="情况1，同一条分支多人开发"></a>情况1，同一条分支多人开发</h3><p>A先做了修改，并提交到远程。B的做法应该如下：</p>
<p>1，先提交本地的修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;x&quot;</span><br></pre></td></tr></table></figure>
<p>2，拉取远程的修改(不合并)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure>
<p>3，开始变基</p>
<ul>
<li>如果在变基过程中，自己有点搞乱了，或者不知道怎么继续操作了，可以<code>git rebase --abort</code> 退出变基操作，则所有变基期间做的操作全部取消，状态回到第2步时的状态。</li>
<li>如果变基过程中因为操作失误，而退出了刚刚的编辑页面，可以<code>git rebase --edit-todo</code> 回到刚刚的编辑页面继续操作。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase</span><br></pre></td></tr></table></figure>
4，此时如果有冲突，变基会被打断！这里先解决冲突，并将所做修改添加到暂存区<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
5，继续变基<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>第4，5步可能会多次重复执行</p>
<p>如果出现了 Successfully rebased and updated xxxx<br>，说明操作成功了！</p>
<p>这时查看 log 就会发现第1步中的commit在最新的位置处，并且远程的修改也按顺序排好了。</p>
<p>变基操作完成，可直接执行 push 操作了。</p>
<hr>
<p>另外，上面的第1，2，3步骤，可以通过配置进行合并执行。</p>
<p>执行如下命令后，可以让每次的<code>git pull</code> 操作 的时候自动 rebase</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config pull.rebase true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>要回到默认的配置，执行<code>git config pull.rebase false</code></p>
</blockquote>
<h3 id="情况2，母分支被超前"><a href="#情况2，母分支被超前" class="headerlink" title="情况2，母分支被超前"></a>情况2，母分支被超前</h3><ul>
<li>A基于 master 切出了分支 app，开始开发。</li>
<li>B也基于 master 切出了分支 fix-app，用于修改线上一个小 bug，并且修改完之后 merge 到 master了。</li>
</ul>
<p>对于 A 来说，应该这么做：</p>
<p>1，先提交本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;x&quot;</span><br></pre></td></tr></table></figure>

<p>2，切换到母分支 master，拉取代码。因为本地 master 未做修改，所以可直接使用 pull，不用担心出现合并问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>而 1，2 步骤可以用一句命令合并。</p>
<blockquote>
<p>git pull &lt;远程库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;  </p>
</blockquote>
<p>（此时本地是app分支）也就是说，将远程的master 分支拉取到本地的 master，并直接合并。<strong>注意</strong>，<code>:master</code> 不能省略，否则就是和<strong>本地当前分支</strong>合并了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin master:master</span><br></pre></td></tr></table></figure>

<p>3，开始变基（此时在app分支）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i master</span><br></pre></td></tr></table></figure>

<p>4，剩下的操作和情况1中的相同。</p>
<h1 id="3，rebase-还能做什么事"><a href="#3，rebase-还能做什么事" class="headerlink" title="3，rebase 还能做什么事"></a>3，rebase 还能做什么事</h1><h2 id="1，可以修改某次的-commit-message"><a href="#1，可以修改某次的-commit-message" class="headerlink" title="1，可以修改某次的 commit message"></a>1，可以修改某次的 commit message</h2><p>比如 log 是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第5次   55555 （commit hash）</span><br><span class="line">第4次   44444</span><br><span class="line">第3次   33333</span><br><span class="line">第2次   22222</span><br><span class="line">第1次   11111</span><br></pre></td></tr></table></figure>

<h3 id="如果要修改第5次的（最近的一次）"><a href="#如果要修改第5次的（最近的一次）" class="headerlink" title="如果要修改第5次的（最近的一次）"></a>如果要修改第5次的（最近的一次）</h3><p>分2种情况：</p>
<p>1，本地刚刚进行了 commit，还没有做其他修改，可执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<p>会出现编辑页面，修改message 保存即可。</p>
<p>2，上次commit之后，继续开发，查看 log 时发现上次的 commit message 写的不好，要进行修改。</p>
<p>分2种方式：</p>
<p>第1种就是使用 stash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add . &#x2F;&#x2F; 提交本地修改到暂存区</span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line">git commit --amend</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<p>第2种就是先将本地的提交（add,commit之后），使用下面介绍的方法做改变。</p>
<h3 id="修改第5次之前提交的-commit-message。"><a href="#修改第5次之前提交的-commit-message。" class="headerlink" title="修改第5次之前提交的 commit message。"></a>修改第5次之前提交的 commit message。</h3><p>以第4次提交为例：</p>
<p>1，需要先确定其祖先commit，可以看到 1-3都是它的祖先，所以这里可以用的 commit hash为 <code>11111 - 33333</code> 都可以的。</p>
<p>2，开始变基</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i  11111</span><br></pre></td></tr></table></figure>
<p>3，在进入的编辑页面中，将要修改的 commit message 前的 <code>pick</code> 改成 <code>r</code>，</p>
<p>4，保存退出后，会进入另一个编辑页面，就可以修改 commit message 了。</p>
<p>5，保存退出后即可完成修改。</p>
<h2 id="2，合并多个-commit"><a href="#2，合并多个-commit" class="headerlink" title="2，合并多个 commit"></a>2，合并多个 commit</h2><p>比如 log 是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第5次   55555 （commit hash）</span><br><span class="line">第4次   44444</span><br><span class="line">第3次   33333</span><br><span class="line">第2次   22222</span><br><span class="line">第1次   11111</span><br></pre></td></tr></table></figure>
<p>比如要将3-5次的 commit 进行合并。</p>
<p>1，和上面的操作类似，先确定其祖先commit，可以看到1和2都是它的祖先，用哪个都可以。</p>
<p>2，开始变基</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i  11111</span><br></pre></td></tr></table></figure>
<p>3，在进入的编辑页面中，将要合并的 commit message 前的 <code>pick</code> 改成 <code>s</code>，</p>
<p><strong>注意</strong>，因为第3-5次进行合并，（<strong>规定</strong>）最上面的（第5次）的 pick 不能动，只修改第3和第4次的 pick –&gt; s 即可。这样，最终第3-5次的会合并为一个新的 commit hash。</p>
<p>4，保存退出后，会进入另一个编辑页面，就可以修改 commit message 了。</p>
<p>5，保存退出后即可完成修改。</p>
<p><strong>特殊情况</strong></p>
<p>在上面的 rebase 操作中，会发现一个情况，比如<code>git rebase -i  11111</code> 时，11111 不会出现在编辑页面中。</p>
<p>也就是说，每次我们指定的祖先 commit hash 并不会出现，这也引出了下面的问题：</p>
<p><strong>如果要修改的是第1次–第5次，那怎么指定祖先？</strong></p>
<p>解决1：<strong>手动添加</strong></p>
<p>1，我们先查看log，复制11111（第1次的hash），进入变基页面后，手动添加这个祖先到<strong>最上面</strong>，在将其他的 pick 全部改成 s。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pick 11111 x</span><br></pre></td></tr></table></figure>

<p>2，剩下的步骤和上面正常情况一样。</p>
<p>解决2：<strong>使用–root</strong>，会发现祖先 commit hash 也在其中。其他步骤一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i --root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>bind和call/apply的实现</title>
    <url>/2020/05/11/bind%E5%92%8Ccall-apply%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>实现原理</p>
<a id="more"></a>

<p>本文是对 <a href="https://www.jianshu.com/p/6958f99db769" target="_blank" rel="noopener">从一道面试题，到“我可能看了假源码”</a> 这篇文章自己的理解和验证。</p>
<h1 id="bind-实现"><a href="#bind-实现" class="headerlink" title="bind 实现"></a>bind 实现</h1><h2 id="bind-基础实现"><a href="#bind-基础实现" class="headerlink" title="bind 基础实现"></a>bind 基础实现</h2><p>不用做嗅探 <code>Function.prototype.bind = Function.prototype.bind || function(context) {}</code> ，因为现代浏览器都支持了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bindFun = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> me = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> argsArr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> me.apply(context, argsArr.slice(<span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 <code>apply</code> 就可简单实现，不做赘述。</p>
<h2 id="bind进阶实现1"><a href="#bind进阶实现1" class="headerlink" title="bind进阶实现1"></a>bind进阶实现1</h2><p>基础实现的问题之一，<strong>存在预置参数功能丢失</strong>，我们来验证一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params">a = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age + a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  age: <span class="number">42</span>,</span><br><span class="line">  getAge: getAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unbindFun = obj.getAge</span><br><span class="line"><span class="built_in">console</span>.log(unbindFun())</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bindFun = unbindFun.bindFun(obj, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(bindFun(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>由下图可以看到，<code>bindFun(5)</code> 传递的参数丢失了：</p>
<img src="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/20200511173016.png" width="450" />

<p>对比正常情况：</p>
<img src="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/20200511173339.png" width="450" />

<p>更好的实现:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bindFun = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> me = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">const</span> finalArgs = args.concat(innerArgs)</span><br><span class="line">    <span class="keyword">return</span> me.apply(context, finalArgs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bind-进阶实现2"><a href="#bind-进阶实现2" class="headerlink" title="bind 进阶实现2"></a>bind 进阶实现2</h2><p>基础实现的第2个问题：</p>
<p>如果 bind 返回的函数，作为构造函数进行 new 调用，绑定的 this 应该被忽略。之前的 <a href="https://www.crane0.com/2020/04/20/this%E6%8C%87%E5%90%91/#more" target="_blank" rel="noopener">this指向</a> 文章有详细说明。</p>
<p>实现的方式，通过原型继承的思想 <code>Child.prototype = new Parent()</code>，对这种情况做了兼容处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bindFun = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> me = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> argsArr = <span class="built_in">Array</span>.prototype.slice(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = <span class="keyword">this</span>.prototype</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> innerArgs = <span class="built_in">Array</span>.prototype.slice(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">const</span> finalArgs = argsArr.concat(innerArgs)</span><br><span class="line">    <span class="keyword">return</span> me.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> F ? <span class="keyword">this</span> : context || <span class="keyword">this</span>, finalArgs)</span><br><span class="line">  &#125;</span><br><span class="line">  bound.prototype = <span class="keyword">new</span> F()</span><br><span class="line">  <span class="keyword">return</span> bound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="apply-实现"><a href="#apply-实现" class="headerlink" title="apply 实现"></a>apply 实现</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.applyFun = <span class="function"><span class="keyword">function</span>(<span class="params">targetObject, argsArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> targetObject === <span class="string">'undefined'</span> || targetObject === <span class="literal">null</span>) &#123;</span><br><span class="line">    targetObject = <span class="built_in">window</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> argsArr === <span class="string">'undefined'</span> || argsArr === <span class="literal">null</span>) &#123;</span><br><span class="line">    argsArr = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  targetObject = <span class="keyword">new</span> <span class="built_in">Object</span>(targetObject)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了不和 targetObject 中原有的属性重合，否则会把原有的属性重写。</span></span><br><span class="line">  <span class="comment">// 所以随便指定一个合理的属性名即可，只要保证不和原有的属性重合即可。</span></span><br><span class="line">  <span class="keyword">const</span> tempKey = <span class="built_in">Symbol</span>()</span><br><span class="line">  targetObject[tempKey] = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> ret = targetObject[tempKey](...argsArr)</span><br><span class="line">  <span class="keyword">delete</span> targetObject[tempKey]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的原理，利用的 <a href="https://www.crane0.com/2020/04/20/this%E6%8C%87%E5%90%91/#more" target="_blank" rel="noopener">this的隐式丢失</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params">a = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age + a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  age: <span class="number">42</span>,</span><br><span class="line">  getAge: getAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = obj.getAge</span><br><span class="line">foo() <span class="comment">// this 已经指向 window</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript 核心</category>
      </categories>
      <tags>
        <tag>bind</tag>
        <tag>call</tag>
        <tag>apply</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>scrollIntoView的问题</title>
    <url>/2020/05/20/scrollIntoView%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>记录 <code>scrollIntoView</code> 在微信浏览器环境下，与谷歌浏览器不一致的行为。</p>
<a id="more"></a>

<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>之前（在 <code>scrollIntoView</code> 兼容性较差时），在页面中要实现点击某个位置，滚动到页面的其他位置可以这样做：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"anchor"</span>&gt;</span>这是要跳转的锚点<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#anchor"</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外，如果要回到页面顶部</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="scrollIntoView"><a href="#scrollIntoView" class="headerlink" title="scrollIntoView"></a>scrollIntoView</h1><p>上面的方式，在滚动时没有任何过渡效果。</p>
<p>添加如下 css ，就可以实现平滑滚动：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123; <span class="attribute">scroll-behavior</span>:smooth; &#125;</span><br></pre></td></tr></table></figure>

<p>这种 css 的方式，也有对应的 js 形式，</p>
<p>调用下面的方法，就会从页面的任意位置<strong>平滑</strong>滚动到 id = <code>#anchor</code> 的元素位置处。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toAnchor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> anchor = <span class="built_in">document</span>.querySelector(<span class="string">'#anchor'</span>)</span><br><span class="line">  anchor.scrollIntoView(&#123; <span class="attr">behavior</span>: <span class="string">'smooth'</span>, <span class="attr">block</span>: <span class="string">'start'</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>参数 <code>block: &#39;start&#39;</code> 其实是默认值（<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView" target="_blank" rel="noopener">参考MDN</a>）， 但如果不写，在微信浏览器中，滚动的距离会变长，不会符合预期。</p>
</li>
<li><p>无论是 css 的形式，还是 js 的形式，Safari 浏览器都不支持。</p>
</li>
</ol>
<blockquote>
<p>可以滚动到指定的位置，但没有平滑的效果。</p>
</blockquote>
]]></content>
      <categories>
        <category>工作遇到的小问题</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>scrollIntoView</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo_next建站_常见问题</title>
    <url>/2020/04/14/hexo_next%E5%BB%BA%E7%AB%99_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>hexo+next建站，常见问题汇总</p>
<a id="more"></a>

<h1 id="使用中文时的问题"><a href="#使用中文时的问题" class="headerlink" title="使用中文时的问题"></a>使用中文时的问题</h1><p>文章文件名中，不能包含中文，否则会有如下报错。</p>
<blockquote>
<p>文件的 title 属性 无所谓。</p>
</blockquote>
<p>错误：<a href="https://github.com/hexojs/hexo/issues/3859" target="_blank" rel="noopener">https://github.com/hexojs/hexo/issues/3859</a></p>
<p>解决：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<p>修改站点配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">post/:abbrlink.html</span></span><br><span class="line"><span class="comment"># abbrlink config</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure>

<h1 id="配置个人域名时的问题"><a href="#配置个人域名时的问题" class="headerlink" title="配置个人域名时的问题"></a>配置个人域名时的问题</h1><p>将个人域名 <code>crane0.com</code> 解析到 <code>crane0.github.io</code> 之后，在该项目的 Settings 中添加配置</p>
<p><img src="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/1.jpg" alt="settings"></p>
<p>第二天时，当访问 <a href="http://crane0.com/" target="_blank" rel="noopener">http://crane0.com/</a> 时发现 404 了，查看上面设置的 Custom domain 竟然为空了。</p>
<ul>
<li>解决办法：</li>
</ul>
<p>在项目的根目录下新建 <code>CNAME</code> 文件（没有后缀名），输入自定义的域名保存即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.crane0.com</span><br></pre></td></tr></table></figure>

<p>之后在部署到 GitHub 时，就不会失效了。</p>
<h1 id="本地图片问题"><a href="#本地图片问题" class="headerlink" title="本地图片问题"></a>本地图片问题</h1><p>在 markdown 的语法中，插入图片的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![描述](图片路径)</span><br></pre></td></tr></table></figure>
<p>但是在 hexo 中貌似失效了。</p>
<p>比如，我的文件目录如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- _post</span><br><span class="line">  -- image</span><br><span class="line">    -- 1.jpg</span><br><span class="line">  -- test.md</span><br></pre></td></tr></table></figure>
<p>在 <code>test.md</code> 中插入图片 <code>![](./image/1.jpg)</code>，发现并没有效果。</p>
<p>在网页中查看该图片时，发现路径是 <code>http://localhost:4000/test/image/1.jpg</code>。</p>
<p>那就简单了，我在当前目录下新建一个和当前文件 <code>test.md</code> 同名的文件夹，放入图片即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- _post</span><br><span class="line">  -- test</span><br><span class="line">    -- 1.jpg</span><br><span class="line">  -- test.md</span><br></pre></td></tr></table></figure>
<p>解决。</p>
<p>另外，其实在站点的配置文件 <code>_config.yml</code> 中，修改 <code>post_asset_folder: true</code>，就可以在运行下面命令时，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new 新文件</span><br></pre></td></tr></table></figure>
<p>同时创建同名的文件夹。</p>
]]></content>
      <categories>
        <category>hexo建站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo_next建站_站点概览模块</title>
    <url>/2020/04/14/hexo_next%E5%BB%BA%E7%AB%99_%E7%AB%99%E7%82%B9%E6%A6%82%E8%A7%88%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>hexo_next建站，站点概览模块</p>
<a id="more"></a>

<h1 id="站点概览"><a href="#站点概览" class="headerlink" title="站点概览"></a>站点概览</h1><h2 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h2><p>在主题配置中，搜索 <code>avatar</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  url: &#x2F;images&#x2F;avatar.jpg</span><br><span class="line">  rounded: true</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure>

<h2 id="头像下的个人介绍"><a href="#头像下的个人介绍" class="headerlink" title="头像下的个人介绍"></a>头像下的个人介绍</h2><p>在blog 根目录的配置文件 <code>_config.yml</code> 中，设置 <code>description</code> 即可。</p>
<h2 id="其他个人链接"><a href="#其他个人链接" class="headerlink" title="其他个人链接"></a>其他个人链接</h2><p>在主题配置中，搜索 <code>social</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;crane0 || fab fa-github</span><br><span class="line">  E-Mail: mailto:bhad5683126@gmail.com || fa fa-envelope</span><br><span class="line">  WeiXin: &#x2F;wechat || fa fa-weixin</span><br></pre></td></tr></table></figure>


<h2 id="个人微信二维码"><a href="#个人微信二维码" class="headerlink" title="个人微信二维码"></a>个人微信二维码</h2><p>因为需要展示一个图片，而原有的配置都是链接，</p>
<p>所以换个思路，新建一个路由，该页面只放一个图片即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page wechat</span><br></pre></td></tr></table></figure>

<p>在 <code>source</code> 目录下会新建一个文件夹，放入二维码图片，</p>
<p>修改 <code>wechat/index.md</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 扫描下面二维码添加微信</span><br><span class="line">---</span><br><span class="line">&lt;img src&#x3D;&quot;.&#x2F;wechat-pr.jpg&quot; style&#x3D;&quot;text-align:center; margin: auto; width: 150px&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo建站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown特殊语法</title>
    <url>/2020/04/14/markdown%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>不同的编译引擎，会有一些特殊的语法</p>
<a id="more"></a>

<p>参考 <a href="https://tding.top/archives/29bfe8c9.html" target="_blank" rel="noopener">https://tding.top/archives/29bfe8c9.html</a></p>
<h1 id="文本居中引用-Centered-Quote"><a href="#文本居中引用-Centered-Quote" class="headerlink" title="文本居中引用 - Centered Quote"></a>文本居中引用 - Centered Quote</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% cq %&#125;世间所有的相遇，都是久别重逢&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>世间所有的相遇，都是久别重逢</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h1 id="提示块-Note"><a href="#提示块-Note" class="headerlink" title="提示块 - Note"></a>提示块 - Note</h1><p>在主题配置文件中，可以修改风格</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Note tag (bs-callout)</span></span><br><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">flat</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span> <span class="comment"># 是否显示图标</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<div class="note default">
            <p>default 提示块标签</p>
          </div>

<div class="note primary">
            <p>primary 提示块标签</p>
          </div>

<div class="note success">
            <p>success 提示块标签</p>
          </div>

<div class="note info">
            <p>info 提示块标签</p>
          </div>

<div class="note warning">
            <p>warning 提示块标签</p>
          </div>

<div class="note danger">
            <p>danger 提示块标签</p>
          </div>

<h1 id="标签-Label"><a href="#标签-Label" class="headerlink" title="标签 - Label"></a>标签 - Label</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label default@默认 %&#125; &#123;% label primary@主要 %&#125; &#123;% label success@成功 %&#125; &#123;% label info@信息 %&#125; &#123;% label warning@警告 %&#125; &#123;% label danger@危险 %&#125;</span><br></pre></td></tr></table></figure>

<span class="label default">默认</span> <span class="label primary">主要</span> <span class="label success">成功</span> <span class="label info">信息</span> <span class="label warning">警告</span> <span class="label danger">危险</span> 

<h1 id="选项卡-Tabs"><a href="#选项卡-Tabs" class="headerlink" title="选项卡 - Tabs"></a>选项卡 - Tabs</h1><p>在主题配置文件中，可以修改风格</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Tabs tag</span></span><br><span class="line"><span class="attr">tabs:</span></span><br><span class="line">  <span class="attr">transition:</span></span><br><span class="line">    <span class="attr">tabs:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">labels:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% tabs tab,1 %&#125; 名字为tab，默认在第1个选项卡，如果是-1则隐藏</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">选项卡 1 </span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">选项卡 2</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab A --&gt;</span><br><span class="line">选项卡 3</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><a href="#tab-1">tab 1</a></li><li class="tab"><a href="#tab-2">tab 2</a></li><li class="tab"><a href="#tab-3">A</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-1"><p>选项卡 1 </p></div><div class="tab-pane" id="tab-2"><p>选项卡 2</p></div><div class="tab-pane" id="tab-3"><p>选项卡 3</p></div></div></div>

<h1 id="按钮-Button"><a href="#按钮-Button" class="headerlink" title="按钮 - Button"></a>按钮 - Button</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% button url, text, icon [class], [title] %&#125;</span><br></pre></td></tr></table></figure>
<div class="text-center">
  <div>
    <a class="btn" href="https://crane0.github.io/ " title="这是博客首页">
            <i class="fa fa-home fa-fw"></i>首页
          </a> 
    <a class="btn" href="https://crane0.github.io/archives/ " title="这是归档">
            <i class="fa fa-archive fa-archive"></i>归档
          </a> 
    <a class="btn" href="https://crane0.github.io/tags/ " title="这是标签">
            <i class="fa fa-tags fa-tags"></i>标签
          </a>
  </div>
</div>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>this指向</title>
    <url>/2020/04/20/this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<p>this 的指向，是在调用函数时，根据执行上下文动态确定的。</p>
<p>包括</p>
<ul>
<li>独立调用</li>
<li>隐式调用</li>
<li>显示绑定</li>
<li>new 调用</li>
<li>this 的优先级</li>
</ul>
<a id="more"></a>

<h1 id="独立调用"><a href="#独立调用" class="headerlink" title="独立调用"></a>独立调用</h1><p>函数在浏览器全局环境中被直接调用:</p>
<ul>
<li>非严格模式下 this 指向 window</li>
<li>在 use strict 指明严格模式的下是 undefined</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">f1() <span class="comment">// window</span></span><br><span class="line">f2() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>定时器中的函数调用，指向 window</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="隐式调用"><a href="#隐式调用" class="headerlink" title="隐式调用"></a>隐式调用</h1><p>发生在上下文对象调用时，this 指向最后调用它的对象。</p>
<p>也就是说，在执行函数时，如果函数中的 this 是被上一级的对象所调用，那么 this 指向的就是上一级的对象；否则指向全局环境。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'crane0'</span>,</span><br><span class="line">    brother: &#123;</span><br><span class="line">        name: <span class="string">'lufei'</span>,</span><br><span class="line">        fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.brother.fn()) <span class="comment">// `lufei`</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;</span><br><span class="line">    text: <span class="string">'o1'</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123;</span><br><span class="line">    text: <span class="string">'o2'</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.fn()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> o3 = &#123;</span><br><span class="line">    text: <span class="string">'o3'</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn = o1.fn</span><br><span class="line">        <span class="keyword">return</span> fn()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o1.fn())  <span class="comment">// o1</span></span><br><span class="line"><span class="built_in">console</span>.log(o2.fn())  <span class="comment">// o1</span></span><br><span class="line"><span class="built_in">console</span>.log(o3.fn())</span><br></pre></td></tr></table></figure>

<p>最后一个会输出 <code>undefined</code>，因为最后在执行时，已经变为独立调用了。此时 <code>this</code> 指向 <code>window</code></p>
<p>问题来了，如何让 <code>console.log(o2.fn())</code> 输出 <code>o2</code> 呢？</p>
<blockquote>
<p>除了用 <code>bind/call/apply</code> 来对 this 的指向进行干预外，有没有其他的办法。</p>
</blockquote>
<p>进行如下改造即可，this 指向最后调用它的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o2 = &#123;</span><br><span class="line">    text: <span class="string">'o2'</span>,</span><br><span class="line">    fn: o1.fn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h2><p>指隐式绑定的函数丢失绑定对象，从而默认绑定到全局或者undefined（取决于是否使用严格模式）。</p>
<p><strong>隐式丢失实质上最后变成了独立调用</strong></p>
<blockquote>
<p>下面3种输出都为 undefined</p>
</blockquote>
<p>1，为函数调用创建别名</p>
<blockquote>
<p>虽然 fn 函数在 foo 对象中作为方法被引用，但在赋值给 f1 后，是在 window 全局环境中执行的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   a: <span class="number">66</span>,</span><br><span class="line">   foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo</span><br><span class="line">bar() <span class="comment">// 独立调用</span></span><br></pre></td></tr></table></figure>

<p>2，作为参数传递时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">   fn(); <span class="comment">// 独立调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">   a: <span class="number">66</span>,</span><br><span class="line">   foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doFoo(obj.foo)</span><br></pre></td></tr></table></figure>

<p>3，传给定时器函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">   a: <span class="number">66</span>,</span><br><span class="line">   foo: foo</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(obj.foo) <span class="comment">// 独立调用</span></span><br></pre></td></tr></table></figure>

<h1 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h1><p>通过 <code>bind/call/apply</code> 改变 this 指向。</p>
<p>三者异同点直接用代码表示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> targetObj = &#123;&#125;</span><br><span class="line">fn.call(targetObj, <span class="string">'arg1'</span>, <span class="string">'arg2'</span>)</span><br></pre></td></tr></table></figure>
<p>等于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> targetObj = &#123;&#125;</span><br><span class="line">fn.apply(targetObj, [<span class="string">'arg1'</span>, <span class="string">'arg2'</span>])</span><br></pre></td></tr></table></figure>
<p>等于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> targetObj = &#123;&#125;</span><br><span class="line">fn.bind(targetObj, <span class="string">'arg1'</span>, <span class="string">'arg2'</span>)()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，如果第一个参数为 <code>null</code> 或 <code>undefined</code>，那就绑定给了 window</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">    name: <span class="string">'crane0'</span>,</span><br><span class="line">    logName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = &#123;</span><br><span class="line">    name: <span class="string">'lufei'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.logName.call(bar)) <span class="comment">// lufei</span></span><br></pre></td></tr></table></figure>

<h1 id="new-调用"><a href="#new-调用" class="headerlink" title="new 调用"></a>new 调用</h1><p>一般情况下，this 绑定给构造出的实例对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bar = <span class="string">"crane0"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="built_in">console</span>.log(instance.bar)  <span class="comment">// crane0</span></span><br></pre></td></tr></table></figure>

<p>这牵扯到2个问题</p>
<ul>
<li><p><a href="https://javascript.ruanyifeng.com/oop/basic.html#toc2" target="_blank" rel="noopener">new 做了什么</a></p>
</li>
<li><p>构造函数和普通函数的区别</p>
</li>
</ul>
<h2 id="new-做了什么"><a href="#new-做了什么" class="headerlink" title="new 做了什么"></a>new 做了什么</h2><ul>
<li>创建一个空对象，作为将要返回的对象实例。</li>
<li>将这个空对象的原型，指向构造函数的prototype属性。</li>
<li>将这个空对象赋值给函数内部的this关键字。</li>
<li>开始执行构造函数内部的代码。</li>
</ul>
<p>简单实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">obj.__proto__ = Foo.prototype</span><br><span class="line">Foo.call(obj)</span><br></pre></td></tr></table></figure>

<h2 id="构造函数和普通函数的区别"><a href="#构造函数和普通函数的区别" class="headerlink" title="构造函数和普通函数的区别"></a>构造函数和普通函数的区别</h2><p>简单来说，普通函数指：内部没有this关键字的函数。</p>
<h2 id="new-调用返回值分析"><a href="#new-调用返回值分析" class="headerlink" title="new 调用返回值分析"></a>new 调用返回值分析</h2><p>当构造函数中出现了显式 return 的情况，有2种场景</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = <span class="string">"crane0"</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="built_in">console</span>.log(instance.user) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>1，此时 instance 是返回的空对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = <span class="string">"crane0"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="built_in">console</span>.log(instance.user) <span class="comment">// crane0</span></span><br></pre></td></tr></table></figure>
<p>2，此时 instance 是返回的目标对象实例 this。</p>
<div class="note success">
            <p>结论：如果构造函数中显式返回一个值，且是一个对象，那么 this 就指向这个返回的对象；如果返回的不是一个对象，那么 this 仍然指向实例。</p>
          </div>

<p>3，对普通函数使用new命令，则会返回一个空对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'this is a message'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> msg = <span class="keyword">new</span> getMessage()</span><br><span class="line"><span class="built_in">console</span>.log(msg) <span class="comment">//空对象</span></span><br></pre></td></tr></table></figure>

<h2 id="箭头函数的-this"><a href="#箭头函数的-this" class="headerlink" title="箭头函数的 this"></a>箭头函数的 this</h2><ul>
<li>箭头函数使用 this 是根据外层（函数或者全局）上下文来决定。</li>
<li><strong>箭头函数的绑定无法被修改！</strong></li>
</ul>
<p>1，简单的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;  </span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">console</span>.log(foo.fn()) <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<p>如果是箭头函数，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;  </span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(foo.fn()) <span class="comment">// &#123;fn: ƒ&#125;</span></span><br></pre></td></tr></table></figure>
<p>2，无法被修改的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = foo.call(obj1)</span><br><span class="line"><span class="built_in">console</span>.log(bar.call(obj2)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>foo() 的 this 已经绑定给 obj1，所以 bar（箭头函数）的 this 绑定给 obj1 了。</p>
<p>此时想将 bar() 的this 绑定给 obj2，发现失败了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.call(obj1)</span><br><span class="line"><span class="built_in">console</span>.log(bar.call(obj2))  <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>既然都是箭头函数，并且是在全局环境中，所以绑定已经没有效果了，this 指向 window。</p>
<p>注意，如果将 <code>var a = 123</code> 改为 <code>const a = 123</code>，输出为 undefined，</p>
<p>因为使用 const 声明的变量不会挂载到 window 全局对象当中。</p>
<h1 id="this-的优先级"><a href="#this-的优先级" class="headerlink" title="this 的优先级"></a>this 的优先级</h1><ul>
<li>new 调用</li>
<li>显示绑定： call、apply、bind 对 this 的绑定</li>
<li>隐式调用</li>
</ul>
<p>结论：new &gt; 显示 &gt; 隐式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2)  <span class="comment">// 2</span></span><br><span class="line">obj2.foo.call(obj1)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>说明显示 &gt; 隐式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(obj1)</span><br><span class="line">bar(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a)  <span class="comment">// &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(baz.a)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>bar 函数内部已经对将 this 绑定为 obj1，而当它作为构造函数，通过 new 调用时，返回的实例已经与 obj1 解绑。</p>
<p>说明 new &gt; 显示。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>this 很基础却很重要，本文系统的总结了 this 的各种情况，明白 this 的指向在工作中是很有必要，不会去犯一些低级错误。</p>
]]></content>
      <categories>
        <category>JavaScript 核心</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>test_my_site</title>
    <url>/2020/04/11/test-my-site/</url>
    <content><![CDATA[<h1 id="这是-test-my-site-文章"><a href="#这是-test-my-site-文章" class="headerlink" title="这是 test-my-site 文章"></a>这是 test-my-site 文章</h1><p>做了一次更新<br>做了第2次更新</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is'</span> <span class="number">123</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a &#x3D; 1</span><br><span class="line"></span><br><span class="line">function() &#123;</span><br><span class="line">  console.log(&#39;this is&#39; 123)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// n 可以省略</span><br><span class="line">git <span class="built_in">log</span> -nx</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; n 可以省略</span><br><span class="line">git log -nx</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>表格</tag>
        <tag>表单验证</tag>
      </tags>
  </entry>
  <entry>
    <title>base64编解码</title>
    <url>/2020/04/21/base64%E7%BC%96%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<p>window 自带的函数，可以进行 base64 编解码，兼容性非常好。</p>
<a id="more"></a>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowBase64/btoa" target="_blank" rel="noopener">MDN参考</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.btoa(<span class="string">"Hello, world"</span>) <span class="comment">// "SGVsbG8sIHdvcmxk"</span></span><br><span class="line"><span class="built_in">window</span>.atob(<span class="string">"SGVsbG8sIHdvcmxk"</span>) <span class="comment">// "Hello, world"</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具方法</category>
      </categories>
      <tags>
        <tag>工具方法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode</title>
    <url>/2020/04/17/leetcode/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i] !== <span class="number">0</span>) &#123;</span><br><span class="line">    arr[j] = arr[i]</span><br><span class="line">    <span class="keyword">if</span> (i !== j) &#123;</span><br><span class="line">      arr[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    j++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+next建站_基础</title>
    <url>/2020/04/14/hexo+next%E5%BB%BA%E7%AB%99_%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>hexo+next建站，基础配置</p>
<a id="more"></a>

<p>参考 <a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26625249</a></p>
<p>使用了 next 主题</p>
<p>下面的命令安装的是最新版本的 v7.x 的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<p>如果之前使用的是 v5.x 的，可以将后面的 <code>themes/next</code> 改为 <code>next-reloaded</code>，其实随便一个名字，然后在站点的配置项中修改主题名称即可。</p>
<h1 id="启用本地搜索"><a href="#启用本地搜索" class="headerlink" title="启用本地搜索"></a>启用本地搜索</h1><p>1，下载依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>2，在 <code>themes/next-reloaded/_config.yml</code> 中，搜索 <code>local_search</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enable: true</span><br></pre></td></tr></table></figure>

<p>完成配置</p>
<blockquote>
<p>还需配图</p>
</blockquote>
<h1 id="修改主题的风格"><a href="#修改主题的风格" class="headerlink" title="修改主题的风格"></a>修改主题的风格</h1><p>在 <code>themes/next-reloaded/_config.yml</code> 中，搜索 <code>Schemes</code>，有4中可以选择，我使用的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scheme: Mist</span><br></pre></td></tr></table></figure>

<h1 id="启用阅读量计数"><a href="#启用阅读量计数" class="headerlink" title="启用阅读量计数"></a>启用阅读量计数</h1><blockquote>
<p>下面的方法，在本地测试环境，显示的统计有问题，不用管。部署后显示就正常了。</p>
</blockquote>
<p>在 <code>themes/next-reloaded/_config.yml</code> 中，搜索<code>busuanzi_count</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enable: true</span><br></pre></td></tr></table></figure>

<h1 id="添加关于，分类，标签的导航栏"><a href="#添加关于，分类，标签的导航栏" class="headerlink" title="添加关于，分类，标签的导航栏"></a>添加关于，分类，标签的导航栏</h1><p>1，运行以下命令添加页面，会在 <code>source</code> 文件夹下分别创建3个文件夹，对应的有 <code>index.md</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br><span class="line">hexo new page categories</span><br><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<blockquote>
<p>页面生成后，默认会在侧边栏中展示出「分类」和 「标签」，但是无法点击。</p>
</blockquote>
<p>2，对于「关于」，可以直接在 <code>index.md</code> 中写内容即可。其他不用配置。</p>
<p>3，对于「分类」和 「标签」，需要再加一个 type 的配置，和 <code>title</code> 保持一致即可。</p>
<blockquote>
<p>如果没有 type 的配置，侧边栏的点击无效，对应的页面虽然会展示，但不会有内容。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-04-13 17:46:28</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-04-13 18:07:52</span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>4，在主题的配置 <code>themes/next/_config.yml</code>中，搜索 <code>menu</code>，将对应的注释打开即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br></pre></td></tr></table></figure>

<p>配置完成。</p>
<h1 id="页面动画效果"><a href="#页面动画效果" class="headerlink" title="页面动画效果"></a>页面动画效果</h1><p>1，在 <code>themes/next/_config.yml</code> 中 搜索 <code>motion</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enable: false</span><br></pre></td></tr></table></figure>

<p>即可关闭所有动画，但其实动画是为了留点时间加载资源，完全禁止掉也不太好。</p>
<p>2，第2种方式，修改主题的源码。</p>
<p>在 <code>themes/next/source/js/motion.js</code>（低版本的不一定是 <code>motion.js</code>），应该也是类似的名称。。。</p>
<p>修改这个函数中的 <code>duration</code> 为 0，个人觉得是比较舒服的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getMistLineSettings(element, translateX) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    e: element,</span><br><span class="line">    p: &#123;translateX&#125;,</span><br><span class="line">    o: &#123;</span><br><span class="line">      duration     : 0,</span><br><span class="line">      sequenceQueue: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的动画时间，可以在这个文件中搜索 <code>duration</code> 找到对应的更改即可。</p>
<h1 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h1><p>开启后，每篇文章下会有一个「打赏」按钮，点击后都会有支付二维码。</p>
<p>在主题配置中，搜索 <code>reward_settings</code>，<code>enable</code> 设置为 true 后就开启了。</p>
<p><code>reward</code> 对应的是二维码图片。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">comment:</span> <span class="string">这是捐赠说明语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">wechatpay:</span> <span class="string">/images/avatar.gif</span></span><br><span class="line">  <span class="attr">alipay:</span> <span class="string">/images/avatar.jpg</span></span><br><span class="line">  <span class="comment">#paypal: /images/paypal.png</span></span><br><span class="line">  <span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure>

<h1 id="文章更新时间"><a href="#文章更新时间" class="headerlink" title="文章更新时间"></a>文章更新时间</h1><p>在主题配置中，搜索 <code>post_meta</code>，<code>updated_at</code> 就是更新时间的配置，可以看到默认是开启的，但还需要其他的配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_meta:</span><br><span class="line">  item_text: true</span><br><span class="line">  created_at: true</span><br><span class="line">  updated_at:</span><br><span class="line">    enable: true</span><br><span class="line">    another_day: true</span><br><span class="line">  categories: true</span><br></pre></td></tr></table></figure>
<p>在文章的 markdown 文件中，添加 <code>modified</code> 字段即可。</p>
<p>还要注意一点，只有当文章内容改变时，才会生效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: test_my_site</span><br><span class="line">date: 2020-04-11 15:25:05</span><br><span class="line">modified: 2020-04-12 20:20:56</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h1 id="滚动条显示百分比"><a href="#滚动条显示百分比" class="headerlink" title="滚动条显示百分比"></a>滚动条显示百分比</h1><blockquote>
<p>这个之后会被顶部的进度条取代。不设置这个了</p>
</blockquote>
<p>在主题配置中，搜索 <code>back2top</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">back2top</span><br><span class="line">  scrollpercent: false</span><br></pre></td></tr></table></figure>

<h1 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h1><p>1，进入来必力官网，<a href="https://www.livere.com，注册登录成功后，在导航栏选择「安装」，" target="_blank" rel="noopener">https://www.livere.com，注册登录成功后，在导航栏选择「安装」，</a></p>
<p>2，选择 City版免费，填入相关信息拿到代码，（其实只需要 data-uid）</p>
<p>3，打开主题配置文件，搜索 <code>livere_uid</code>，填入即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">livere_uid: xxxx</span><br></pre></td></tr></table></figure>


<h1 id="添加文章字数统计和阅读时长，底部站点总字数"><a href="#添加文章字数统计和阅读时长，底部站点总字数" class="headerlink" title="添加文章字数统计和阅读时长，底部站点总字数"></a>添加文章字数统计和阅读时长，底部站点总字数</h1><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<h2 id="站点配置文件-config-yml-新增如下："><a href="#站点配置文件-config-yml-新增如下：" class="headerlink" title="站点配置文件_config.yml 新增如下："></a>站点配置文件_config.yml 新增如下：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line"> #文章内是否显示</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line"> # 网页底部是否显示</span><br><span class="line">  total_symbols: true  # 显示站点总字数</span><br><span class="line">  total_time: false</span><br></pre></td></tr></table></figure>

<h2 id="主题配置文件-config-yml，搜索-symbols-count-time，"><a href="#主题配置文件-config-yml，搜索-symbols-count-time，" class="headerlink" title="主题配置文件_config.yml，搜索 symbols_count_time，"></a><strong>主题</strong>配置文件_config.yml，搜索 <code>symbols_count_time</code>，</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true  # false会显示一行</span><br><span class="line">  item_text_post: true  # 显示文字名称,设为false后只显示图标和统计数字,不显示文字名称</span><br><span class="line">  item_text_total: true # 底部footer是否显示站点字数统计属性文字</span><br><span class="line">  wpm: 275              # 一分钟阅读的字数，可不设置</span><br></pre></td></tr></table></figure>


<p>添加之后，本地测试环境的时长可能会显示 NaN，但不影响，部署后的正式环境没有问题。</p>
<h1 id="建站时间"><a href="#建站时间" class="headerlink" title="建站时间"></a>建站时间</h1><p>在主题配置中，搜索 <code>since</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  since: 2020 # 建站时间，默认当前年份</span><br></pre></td></tr></table></figure>

<h1 id="网站图标设置"><a href="#网站图标设置" class="headerlink" title="网站图标设置"></a>网站图标设置</h1><p>在主题配置中，搜索 <code>favicon</code>，修改图片即可。</p>
<blockquote>
<p>可以在这里找图标 </p>
</blockquote>
<ul>
<li><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a>   </li>
<li><a href="https://www.easyicon.net/" target="_blank" rel="noopener">https://www.easyicon.net/</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: &#x2F;images&#x2F;favicon-16*16.png</span><br><span class="line">  medium: &#x2F;images&#x2F;favicon-32*32.png</span><br><span class="line">  apple_touch_icon: &#x2F;images&#x2F;favicon-32*32.png</span><br><span class="line">  safari_pinned_tab: &#x2F;images&#x2F;favicon-32*32.png</span><br></pre></td></tr></table></figure>

<h1 id="相关文章推荐"><a href="#相关文章推荐" class="headerlink" title="相关文章推荐"></a>相关文章推荐</h1><p>在每篇文章的最后，推荐相关标签的。</p>
<blockquote>
<p>必须有相同标签的文章，才会显示推荐的文章列表</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-related-popular-posts --save</span><br></pre></td></tr></table></figure>

<p>在主题配置文件中，搜索 <code>related_posts</code>,</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">title:</span> <span class="comment"># Custom header, leave empty to use the default one</span></span><br><span class="line">  <span class="attr">display_in_home:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">params:</span></span><br><span class="line">    <span class="attr">maxCount:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h1 id="首页显示摘要"><a href="#首页显示摘要" class="headerlink" title="首页显示摘要"></a>首页显示摘要</h1><p>首页默认是展示所有文章的所有内容，这样会导致内容过多，</p>
<p>首页显示摘要即可。</p>
<p>解决：</p>
<p>版本，next  v7.x</p>
<p>在文章中使用 <code>&lt;!-- more --&gt;</code> 来截断，上面的就是摘要，下面的是正文。并且会在首页的摘要中添加阅读全文的按钮。</p>
<p>7.6版本之前，通过在主题文件中，</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scroll_to_more:</span> <span class="literal">true</span>      <span class="comment"># 点击阅读全文后是否跳到&lt;!--more--&gt;标记处,设为false时点击阅读全文可以从头阅读</span></span><br><span class="line"></span><br><span class="line"><span class="attr">save_scroll:</span> <span class="literal">false</span>        <span class="comment"># 自动保存每篇文章或页面上一次滚动的地方</span></span><br><span class="line"></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span> <span class="comment"># 自动在首页对文章进行摘要描述作为前言文本</span></span><br><span class="line"></span><br><span class="line"><span class="attr">auto_excerpt:</span>   <span class="comment"># 是否自动截取摘要</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment"># 设置为true则自动截取150字当做首页摘要</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span>   <span class="comment"># 自动截取的字数</span></span><br></pre></td></tr></table></figure>

<h1 id="顶部加载资源滚动条"><a href="#顶部加载资源滚动条" class="headerlink" title="顶部加载资源滚动条"></a>顶部加载资源滚动条</h1><p>基于这个插件 <code>https://github.com/theme-next/theme-next-pace</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd themes&#x2F;next</span><br><span class="line"></span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-pace source&#x2F;lib&#x2F;pace</span><br></pre></td></tr></table></figure>

<p>在主题配置文件，搜索 <code>pace</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pace:</span><br><span class="line">  enable: true</span><br><span class="line">  theme: minimal</span><br></pre></td></tr></table></figure>

<h1 id="代码块风格"><a href="#代码块风格" class="headerlink" title="代码块风格"></a>代码块风格</h1><p>next 使用的是 <a href="https://github.com/chriskempson/tomorrow-theme" target="_blank" rel="noopener">https://github.com/chriskempson/tomorrow-theme</a></p>
<p>在主题配置文件中，搜索 <code>codeblock</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  highlight_theme: normal</span><br><span class="line">  # 显示复制按钮</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    # 复制成功后，按钮变✔️</span><br><span class="line">    show_result: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    # 2 中风格选择</span><br><span class="line">    style: mac</span><br></pre></td></tr></table></figure>

<h2 id="代码块顶部显示代码路径"><a href="#代码块顶部显示代码路径" class="headerlink" title="代码块顶部显示代码路径"></a>代码块顶部显示代码路径</h2><p>在三个冒号后添加 <code>html 路径即可</code></p>
<figure class="highlight html"><figcaption><span>a/b/c</span></figcaption><table><tr><td class="code"><pre><span class="line">const a = 123</span><br></pre></td></tr></table></figure>

<h1 id="顶部阅读进度条"><a href="#顶部阅读进度条" class="headerlink" title="顶部阅读进度条"></a>顶部阅读进度条</h1><p>在主题配置文件中，搜索 <code>reading_progress</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reading_progress:</span><br><span class="line">  enable: true</span><br><span class="line">  # Available values: top | bottom</span><br><span class="line">  position: top</span><br><span class="line">  color: &quot;#37c6c0&quot;</span><br><span class="line">  height: 3px</span><br></pre></td></tr></table></figure>

<h1 id="设置右上角-github-图标"><a href="#设置右上角-github-图标" class="headerlink" title="设置右上角 github 图标"></a>设置右上角 github 图标</h1><p>在主题配置文件中，搜索 <code>github_banner</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github_banner:</span><br><span class="line">  enable: true</span><br><span class="line">  permalink: https:&#x2F;&#x2F;github.com&#x2F;crane0&#x2F;crane0.github.io</span><br><span class="line">  title: Follow me on GitHub</span><br></pre></td></tr></table></figure>

<h1 id="设置阅读位置标记"><a href="#设置阅读位置标记" class="headerlink" title="设置阅读位置标记"></a>设置阅读位置标记</h1><blockquote>
<p>我未设置</p>
</blockquote>
<p>点击标签按钮，可以记住当前阅读位置，下次打开页面会自动到之前记忆的位置。</p>
<p>在主题配置文件中，搜索 <code>bookmark</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bookmark:</span><br><span class="line">  enable: true</span><br><span class="line">  # Customize the color of the bookmark.</span><br><span class="line">  color: &quot;#222&quot;</span><br><span class="line">  # If auto, save the reading progress when closing the page or clicking the bookmark-icon.</span><br><span class="line">  # If manual, only save it by clicking the bookmark-icon.</span><br><span class="line">  save: auto</span><br></pre></td></tr></table></figure>

<h1 id="页面底部信息"><a href="#页面底部信息" class="headerlink" title="页面底部信息"></a>页面底部信息</h1><h2 id="页面底部信息居中显示"><a href="#页面底部信息居中显示" class="headerlink" title="页面底部信息居中显示"></a>页面底部信息居中显示</h2><p>如果使用的是 Mist 风格，在 <code>themes/next/source/css/_schemes/Muse</code> 文件夹下，搜索 <code>footer-inner</code>，将其值改为 <code>center</code> 即可。</p>
<blockquote>
<p>我用的 Muse 风格</p>
</blockquote>
<h2 id="隐藏-Hexo-和-NexT-信息"><a href="#隐藏-Hexo-和-NexT-信息" class="headerlink" title="隐藏 Hexo 和 NexT 信息"></a>隐藏 Hexo 和 NexT 信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  powered: false</span><br></pre></td></tr></table></figure>

<h2 id="文末版权声明"><a href="#文末版权声明" class="headerlink" title="文末版权声明"></a>文末版权声明</h2><p>在主题配置文件中，搜索 <code>creative_commons</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: true</span><br><span class="line">  post: true</span><br><span class="line">  language: zh-CN</span><br></pre></td></tr></table></figure>

<p>改文章末尾就是例子，默认只展示这3个，对应文字的修改在 <code>themes/next/languages/zh-CN.yml</code> 搜索 <code>copyright</code></p>
<p>原始链接对应的地址的host，是在<strong>站点的配置文件</strong>中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: http:&#x2F;&#x2F;crane0.github.io</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo建站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>提升</title>
    <url>/2020/04/23/%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>涉及变量和函数提升。</p>
<a id="more"></a>

<h1 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h1><p>当通过 <code>var</code> 声明变量和赋值时，只会将<strong>声明</strong>进行提升到<strong>本层作用域</strong>最顶层。</p>
<p>并且不会被 <code>if else</code> 影响。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar)</span><br><span class="line">  <span class="keyword">if</span> (bar &gt; <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>因为 bar 在函数内部会提升到顶层，所以相当于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bar</span><br><span class="line">  <span class="built_in">console</span>.log(bar)</span><br><span class="line">  <span class="keyword">if</span> (bar &gt; <span class="number">4</span>) &#123;</span><br><span class="line">    bar = <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h1 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h1><p>函数的声明有 2 种方式</p>
<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>相当于变量的提升。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn</span><br><span class="line"><span class="built_in">console</span>.log(fn) <span class="comment">// undefined</span></span><br><span class="line">fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数式声明"><a href="#函数式声明" class="headerlink" title="函数式声明"></a>函数式声明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(fn) <span class="comment">// ƒ fn() &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(fn) <span class="comment">// ƒ fn() &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>提升优先级：函数式声明 &gt; 变量</p>
          </div>]]></content>
      <categories>
        <category>JavaScript 核心</category>
      </categories>
      <tags>
        <tag>提升</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2020/04/23/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>涉及作用域，执行上下文，调用栈，内存管理。</p>
<a id="more"></a>

<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>规定了特定场景下，变量的查询规则。</p>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域（ES6新增）</li>
</ul>
<div class="note info">
            <p>js 执行函数时，遇见变量读取其值，这时候会“就近”先在函数内部找该变量的声明或者赋值情况。（涉及变量提升和变量的声明方式），如果在函数内无法找到该变量，会到更上层作用域（可能还是一个函数作用域）中查找，一直找到全局作用域。</p>
          </div>

<p><strong>注意，作用域的位置和函数的调用位置无关。</strong></p>
<h2 id="全局作用域和函数作用域"><a href="#全局作用域和函数作用域" class="headerlink" title="全局作用域和函数作用域"></a>全局作用域和函数作用域</h2><p>2个简单例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="string">'out_bar'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">'inner_bar'</span>  </span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// inner_bar</span></span><br></pre></td></tr></table></figure>

<p>foo 函数在自身函数作用域内找到了 b 变量，输出 inner_bar。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="string">'out_bar'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">  &#125;</span><br><span class="line">  inner()</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// out_bar</span></span><br></pre></td></tr></table></figure>

<p>inner 函数在自身函数作用域内未找到 b 变量，则继续向外扩大搜索范围，在全局作用域中找到 b 变量，输出 out_bar。</p>
<div class="note info">
            <p>作用域链：变量在作用域的查找过程，是逐渐向外层扩散的，如同环环相扣的链条。<br>作用域链保证了变量和函数的有序访问。</p>
          </div>

<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>ES6 中增加了 <code>const</code> 和 <code>let</code> 关键字来声明变量，而由它们声明的变量的 <code>{}</code> 内构成了块级作用域。</p>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p><a href="https://www.crane0.com/2020/04/23/提升/" target="_blank" rel="noopener">变量提升</a>，我们并不陌生，这里稍微提下，为了引出暂时性死区。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar)</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>因为 bar 在函数内部会提升到顶层，所以相当于:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bar</span><br><span class="line">  <span class="built_in">console</span>.log(bar)</span><br><span class="line">  bar = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>当使用 <code>let</code> 声明时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar)</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// Uncaught ReferenceError: Cannot access 'bar' before initialization</span></span><br></pre></td></tr></table></figure>

<p>因为在使用 <code>const</code> 或 <code>let</code> 声明变量时，会针对这个变量形成一个封闭的块级作用域，在该作用域中，不会进行变量提升。</p>
<p>也因此，在相应花括号形成的作用域中，存在一个“死区” TDZ（Temporal Dead Zone），<strong>起始于花括号开头，终止于相关变量声明时</strong>。</p>
<ul>
<li>2种情况</li>
</ul>
<p>1，因为这个变量已经存在，不会往外层作用域查找。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar)</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// 依旧会报错：Uncaught ReferenceError: Cannot access 'bar' before initialization</span></span><br></pre></td></tr></table></figure>

<p>2，在下面的 foo 函数中，如果第一个参数没有传，将会使用第二个参数作为第一个实参值。</p>
<p>如果参数传递 <code>undefined</code>，是作为缺省处理的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg1 = arg2, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg1, arg2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="literal">undefined</span>, <span class="string">'arg2'</span>) <span class="comment">// Uncaught ReferenceError: Cannot access 'arg2' before initialization</span></span><br></pre></td></tr></table></figure>
<p>此时，会读取 <code>arg2</code> 的值赋值给 <code>arg1</code>，此时 <code>arg2</code> 所处的状态就和第一种情况 <code>let bar = 3</code> 类似了，也就是说:</p>
<blockquote>
<p>函数参数默认值也会受到 TDZ 影响。</p>
</blockquote>
<p>另外，如果是 <code>foo(null, &#39;arg2&#39;)</code>，并不会作为缺省处理的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg1 = arg2, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg1, arg2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="literal">null</span>, <span class="string">'arg2'</span>) <span class="comment">// null, arg2</span></span><br></pre></td></tr></table></figure>

<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>执行上下文就是当前代码的执行环境/作用域，和作用域链相辅相成，但又是完全不同的两个概念。</p>
<p>直观上看，执行上下文包含了作用域链，同时它们又像是一条河的上下游：有了作用域链，才有了执行上下文的一部分。</p>
<h2 id="代码执行的-2-个阶段"><a href="#代码执行的-2-个阶段" class="headerlink" title="代码执行的 2 个阶段"></a>代码执行的 2 个阶段</h2><ul>
<li>代码预编译阶段</li>
<li>代码执行阶段</li>
</ul>
<h3 id="代码预编译阶段"><a href="#代码预编译阶段" class="headerlink" title="代码预编译阶段"></a>代码预编译阶段</h3><p>虽然 js 是解释型语言，编译一行执行一行。但是在代码执行前，js 引擎确实会做一些“预先准备工作”。</p>
<ul>
<li>进行语法分析，确认语法无误</li>
<li>对变量的内存空间进行分配，变量提升就发生在这个阶段。<ul>
<li>进行变量声明</li>
<li>变量声明进行提升，但是值为 undefined</li>
<li>所有函数式声明进行提升（优先级 &gt; 变量提升）</li>
</ul>
</li>
</ul>
<p>经历过以上，<strong>作用域</strong>也就确定了。</p>
<h3 id="代码执行阶段"><a href="#代码执行阶段" class="headerlink" title="代码执行阶段"></a>代码执行阶段</h3><p>因为函数在调用时，才会开始创建对应的执行上下文，<strong>作用域链</strong>就是在执行上下文的创建阶段完全生成的。<br>执行上下文包括了：</p>
<ul>
<li>变量对象</li>
<li>作用域链</li>
<li>this 的指向</li>
</ul>
<h1 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h1><p>函数之间的调用发生嵌套时，就会形成一些列的调用栈。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo3()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo4()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">debugger</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo4'</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo1()</span><br></pre></td></tr></table></figure>

<img src="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/2.jpg" width="450" />

<div class="note warning">
            <p>一般来说，在函数执行完毕并出栈后，函数内局部变量在下一个垃圾回收节点会被回收，该函数对应的执行上下文将会被销毁，这也正是在外部无法访问函数内定义的变量的原因。<br>也就是说，只有在函数执行时，相关函数才可以访问该变量，该变量在预编译阶段进行创建，在执行阶段进行激活，在函数执行完毕后，相关上下文被销毁。</p>
          </div>

<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><div class="note info">
            <p>函数嵌套函数时，内层函数引用了外层函数作用域下的变量，并且内层函数在全局环境下可访问，就形成了闭包。</p>
          </div>

<p>内层函数在全局环境下如何可访问 ?</p>
<ul>
<li>外层函数返回</li>
<li>将内层函数赋值给全部变量</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">1</span></span><br><span class="line">  num++</span><br><span class="line">  <span class="keyword">debugger</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getNum = numGenerator()</span><br><span class="line">getNum()</span><br></pre></td></tr></table></figure>

<p>可以看到，numGenerator 函数执行完毕出栈后，变量 num 不会消失，成为一个 Closure，仍然可以被外界访问。</p>
<img src="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/3.jpg" width="450" />

<p>上面说到在正常情况下，函数执行完毕后上下文即被销毁，函数内局部变量在下一个垃圾回收节点会被回收。</p>
<div class="note info">
            <p>闭包的基本原理：在外层函数中如果返回了另一个函数，且这个返回的函数使用了外层函数内的变量，外界便能够通过这个返回的函数获取原外层函数内部的变量值。</p>
          </div>

<h2 id="典型例题和用途"><a href="#典型例题和用途" class="headerlink" title="典型例题和用途"></a>典型例题和用途</h2><h3 id="例题：函数调用位置"><a href="#例题：函数调用位置" class="headerlink" title="例题：函数调用位置"></a>例题：函数调用位置</h3><p>本文一开始就提到：<strong>作用域的位置和函数的调用位置无关。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(c)            </span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    fn = inner</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">100</span></span><br><span class="line">    fn()    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>

<p>上面的代码会报错 <code>Uncaught ReferenceError: c is not defined</code>，</p>
<p>因为调用 <code>c</code> 是 <code>bar</code> 函数的内部变量，<code>inner</code> 函数的作用域链并没有变量 <code>c</code></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>可以实现单例模式</p>
<div class="note info">
            <p>保障一个类只有一个实例，并提供一个访问它的全局访问点。</p>
          </div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = <span class="string">'crane0'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> singleFun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> singlePerson</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!singlePerson) &#123;</span><br><span class="line">      singlePerson = <span class="keyword">new</span> Person()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singlePerson</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> singleFun()</span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> singleFun()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance1 === instance2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript 核心</category>
      </categories>
      <tags>
        <tag>变量提升</tag>
      </tags>
  </entry>
  <entry>
    <title>资源的渲染</title>
    <url>/2020/09/07/%E8%B5%84%E6%BA%90%E7%9A%84%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p>简单介绍浏览器如何渲染 html, css, js</p>
<a id="more"></a>

<h1 id="1，构建DOM树"><a href="#1，构建DOM树" class="headerlink" title="1，构建DOM树"></a>1，构建DOM树</h1><p>HTML解析器，会将 HTML 解析为 DOM 树，浏览器才能识别。</p>
<img src="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/20200907115024.png" width="450" />

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span></span><br></pre></td></tr></table></figure>

<p>DOM 树，是保存在内存中树状结构，通过 JavaScript 来查询或修改其内容。</p>
<h1 id="2，样式计算"><a href="#2，样式计算" class="headerlink" title="2，样式计算"></a>2，样式计算</h1><h2 id="2-1，解析-CSS-文本"><a href="#2-1，解析-CSS-文本" class="headerlink" title="2.1，解析 CSS 文本"></a>2.1，解析 CSS 文本</h2><p>CSS 来源：</p>
<ul>
<li>link</li>
<li>style 标签</li>
<li>内联样式</li>
</ul>
<p>渲染引擎会将 link 和 style 标签的 cssText 解析放入 styleSheets，内联样式放入 CSSStyleDeclaration</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.styleSheets</span><br><span class="line"></span><br><span class="line">element.style</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最终，可以通过 <code>window.getComputedStyle()</code> 获取所有的 CSS属性。</p>
</blockquote>
<h2 id="2-2，属性值标准化"><a href="#2-2，属性值标准化" class="headerlink" title="2.2，属性值标准化"></a>2.2，属性值标准化</h2><img src="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/20200907115129.png" width="450" />

<p>虽然在浏览器中查看时，还是原来的属性值，但浏览器渲染时用的都是标准化的属性值。</p>
<h2 id="2-3，计算-DOM-树中每个节点的样式"><a href="#2-3，计算-DOM-树中每个节点的样式" class="headerlink" title="2.3，计算 DOM 树中每个节点的样式"></a>2.3，计算 DOM 树中每个节点的样式</h2><p>这里涉及样式继承，优先级（来源）等问题，不做考虑。</p>
<img src="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/20200907115205.png" width="450" />

<h1 id="3，布局"><a href="#3，布局" class="headerlink" title="3，布局"></a>3，布局</h1><p>计算出 DOM 树中可见元素的几何位置。</p>
<p>DOM 树中，有的标签是不展示的</p>
<ul>
<li>head</li>
<li>display: none 的元素</li>
</ul>
<p>所以，还得有一个 <strong>布局（渲染）树</strong></p>
<blockquote>
<p>相对于DOM 树，就是去掉了不展示的标签。</p>
</blockquote>
<img src="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/20200907115229.png" width="450" />

<h1 id="4，分层"><a href="#4，分层" class="headerlink" title="4，分层"></a>4，分层</h1><p>浏览器的页面实际上会被分成很多个图层，这些图层叠加后合成了最终的页面。（和 PS 中差不多）</p>
<p>页面中会有很多复杂的效果，3D 变换，甚至页面滚动等。渲染引擎会为这些特定的节点，生成专用的图层，并生成一棵图层树（LayerTree）</p>
<p><strong>chrome 的 Layer标签</strong> 可以看到图层最终的分层效果。</p>
<h2 id="4-1，如何分层？"><a href="#4-1，如何分层？" class="headerlink" title="4.1，如何分层？"></a>4.1，如何分层？</h2><ol>
<li>拥有<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">层叠上下文</a>属性的元素会被提升为单独的一层。<br>但经测试，只有下面的会被分层</li>
</ol>
<ul>
<li>transform: translateY 和 Z，X不会。</li>
<li>transform: rotate 相关</li>
<li>filter: blur(5px);</li>
<li>will-change: transform;</li>
</ul>
<ol start="2">
<li>滚动条是单独一层。</li>
<li>需要剪裁（clip）的地方也会被创建为图层。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.text</span> &#123;</span></span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 200px;</span><br><span class="line">      overflow: auto;</span><br><span class="line">      background-color: aquamarine;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">    飞跃那辽阔碧海蓝天，飞向那温暖的春天。</span><br><span class="line">    飞跃那辽阔碧海蓝天，飞向那温暖的春天。</span><br><span class="line">    飞跃那辽阔碧海蓝天，飞向那温暖的春天。</span><br><span class="line">    飞跃那辽阔碧海蓝天，飞向那温暖的春天。</span><br><span class="line">    飞跃那辽阔碧海蓝天，飞向那温暖的春天。</span><br><span class="line">    飞跃那辽阔碧海蓝天，飞向那温暖的春天。</span><br><span class="line">    飞跃那辽阔碧海蓝天，飞向那温暖的春天。</span><br><span class="line">    飞跃那辽阔碧海蓝天，飞向那温暖的春天。</span><br><span class="line">    飞跃那辽阔碧海蓝天，飞向那温暖的春天。</span><br><span class="line">    飞跃那辽阔碧海蓝天，飞向那温暖的春天。</span><br><span class="line">    飞跃那辽阔碧海蓝天，飞向那温暖的春天。</span><br><span class="line">    飞跃那辽阔碧海蓝天，飞向那温暖的春天。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="5，绘制和栅格化"><a href="#5，绘制和栅格化" class="headerlink" title="5，绘制和栅格化"></a>5，绘制和栅格化</h1><p>绘制对应的有指令，比如先指定坐标，画一个矩形，填充颜色。这些指令会生成一个绘制列表，交给<strong>合成线程</strong>绘制。</p>
<img src="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/20200907115305.png" width="450" />

<p>因为浏览器的视口大小是固定的，但页面的内容可能会有很多，会出现滚动条。所以，不会一次性绘制出所有的内容。</p>
<p>基于这个原因，<strong>合成线程会将图层划分为图块</strong>。图块的大小也不固定，可以在 Layer 标签中看到。</p>
<p>合成线程会优先对视口附近的图块进行<strong>栅格化</strong>，也就是将图块绘制成位图。</p>
<blockquote>
<p>栅格化通常会用到 GPU，生成的位图也都在GPU的内存中。</p>
</blockquote>
<p>==注意==，上面所说的不会一次性绘制出所有的内容，是指不会在一个图块上绘制所有的内容。</p>
<h1 id="6，合成展示"><a href="#6，合成展示" class="headerlink" title="6，合成展示"></a>6，合成展示</h1><p>当所有的图块都栅格化后，合成线程会生成一个绘制图块的命令——“DrawQuad”，并将该命令提交给浏览器进程。</p>
<p>浏览器进程中的 viz 组件根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>
<img src="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/20200907115338.png" width="450" />

<h1 id="7，其他问题"><a href="#7，其他问题" class="headerlink" title="7，其他问题"></a>7，其他问题</h1><h2 id="7-1，重绘重排"><a href="#7-1，重绘重排" class="headerlink" title="7.1，重绘重排"></a>7.1，重绘重排</h2><img src="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/20200907115411.png" width="450" />

<ul>
<li>解析 DOM</li>
<li>解析 CSS</li>
<li>布局</li>
<li>分层</li>
<li>绘制</li>
<li>合成展示<ul>
<li>图块</li>
<li>栅格化</li>
<li>draw quad</li>
<li>展示</li>
</ul>
</li>
</ul>
<p>1，修改了元素的几何属性，会触发重排等后面一系列操作。</p>
<p>2，修改了颜色等，没有影响到几何属性时，会触发重绘等后面一系列操作。</p>
<p>3，部分属性，比如 transform ，不会触发重绘重排。直接进入合成展示。</p>
<p>所以，为了减少重绘重排</p>
<ul>
<li>使用 class，而不是频繁操作 style<blockquote>
<p>如果添加多个样式，一个class，比多次 element.style 强的多。而且就算是一个样式，也保不准之后不会再添加新的样式。</p>
</blockquote>
</li>
<li>批量 DOM 操作时，使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createDocumentFragment" target="_blank" rel="noopener">createDocumentFragment</a></li>
<li>will-change: transform 可以强制使用 GPU<blockquote>
<p>GPU是专为执行复杂的数学和几何计算而设计的，可以让CPU从图形处理的任务中解放出来，从而执行其他更多的系统任务，例如，页面的计算与重绘。</p>
</blockquote>
</li>
</ul>
<h2 id="7-2，阻塞问题"><a href="#7-2，阻塞问题" class="headerlink" title="7.2，阻塞问题"></a>7.2，阻塞问题</h2><p><a href="https://juejin.im/post/6844903667733118983" target="_blank" rel="noopener">参考</a></p>
<p>1，js 文件下载和执行，会阻塞 DOM 树的解析。</p>
<p>2，css 文件 和 js 文件会阻塞DOM树吗？</p>
<ul>
<li>css加载不会阻塞DOM树解析，但是会阻塞DOM树渲染。</li>
</ul>
<p>如果不阻塞渲染，可能会多次渲染。</p>
<blockquote>
<p>DOM解析和CSS解析是两个并行的进程</p>
</blockquote>
<ul>
<li>css加载会阻塞后面的js语句的执行。</li>
</ul>
<p>因为可能后面的 js 会操作 CSS</p>
]]></content>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2020/04/24/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>js 依赖宿主浏览器的垃圾回收机制，内存的释放一般情况下不需要程序员关心。但某些情况下还是需要注意，否则会出现内存泄漏现象。</p>
<a id="more"></a>

<blockquote>
<p>内存管理是指对内存生命周期的管理。</p>
</blockquote>
<p>内存生命周期：分配内存 –&gt; 使用（读写）内存 –&gt; 释放内存</p>
<h1 id="栈空间和堆空间"><a href="#栈空间和堆空间" class="headerlink" title="栈空间和堆空间"></a>栈空间和堆空间</h1><p>内存空间的分为：栈空间和堆空间。</p>
<p>在 js 中的，数据类型分为基本和引用数据类型。</p>
<ul>
<li>栈空间，存放基本数据类型。</li>
<li>堆空间，存放引用数据类型。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'crane0'</span></span><br><span class="line"><span class="keyword">let</span> c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> d = &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure>
<p>内存分类图：</p>
<img src="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/4.jpg" width="450" />

<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>2种算法</p>
<ul>
<li>引用计数</li>
<li>标记清除</li>
</ul>
<blockquote>
<p>从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。</p>
</blockquote>
<p>标记清除算法把“对象是否不再需要”简化定义为“对象是否可以获得”。需要说明的一点是，因为“有零引用的对象”总是不可获得的。</p>
<p>简单的理解：算法从“根”对象（js 中就是 window）定期的找所有引用的对象。</p>
<p>垃圾回收器根据这个算法，可以找到所有可以获得和不可获得的对象。</p>
<h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1><p>概念：指内存空间已经不再使用，但因为某种原因没有得到释放的情况。</p>
<p>危害：直接导致程序运行缓慢，甚至崩溃。</p>
<h2 id="典型场景举例"><a href="#典型场景举例" class="headerlink" title="典型场景举例"></a>典型场景举例</h2><p>首选需要清楚2点：</p>
<ul>
<li>全局变量的生命周期会一直持续，直到页面卸载。</li>
<li>局部变量的生命周期从执行函数开始，直到函数执行结束。（闭包情况特殊）</li>
</ul>
<h3 id="例1，获取了页面元素后赋值给变量，最后只在-DOM-Tree-中移除该元素。"><a href="#例1，获取了页面元素后赋值给变量，最后只在-DOM-Tree-中移除该元素。" class="headerlink" title="例1，获取了页面元素后赋值给变量，最后只在 DOM Tree 中移除该元素。"></a>例1，获取了页面元素后赋值给变量，最后只在 DOM Tree 中移除该元素。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"more"</span>)</span><br><span class="line">element.innerHTML = <span class="string">"阅读全文"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除 element 节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  element.parentNode.removeChild(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但声明的 <code>element</code> 对象还是在内存中，所以对应的元素占用的内存还是无法释放。</p>
<blockquote>
<p>这里默认的情况是，既然已经移除对应的页面元素，这个声明的变量也不会再使用了。</p>
</blockquote>
<img src="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/5.jpg" width="450" />

<p>所以在 <code>remove</code>方法中，添加 <code>element = null</code> 才能真正释放内存。</p>
<h3 id="例2，未解绑事件监听函数"><a href="#例2，未解绑事件监听函数" class="headerlink" title="例2，未解绑事件监听函数"></a>例2，未解绑事件监听函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"more"</span>)</span><br><span class="line">element.innerHTML = <span class="string">"&lt;button id='btn'&gt;点击btn&lt;/button&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">element.innerHTML = <span class="string">''</span></span><br></pre></td></tr></table></figure>

<p>除了和 例1 一样的情况：<code>btn</code> 变量对应的元素所占用的内存外，还有一个事件解绑的问题。</p>
<details>
  <summary>为什么要将事件解绑？</summary>

<blockquote>
<p>个人理解：解绑后对应的事件监听函数的引用就会为 0，才可以被垃圾回收。所以也需要对事件解绑。</p>
</blockquote>
</details>

<p>针对本例，元素已经从 DOM Tree 中移除时，可以使用 <code>btn = null</code> 直接解绑。</p>
<p>这里涉及事件监听绑定与解绑问题。</p>
<h4 id="事件绑定问题："><a href="#事件绑定问题：" class="headerlink" title="事件绑定问题："></a>事件绑定问题：</h4><ol>
<li>传入匿名函数的方式，绑定时最简单。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"more"</span>)</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但解绑比较困难，下面的代码无效：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面的情况，如果要解绑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>传入已声明的函数</li>
</ol>
<p>下面的情况，是否需要设置： <code>element = null</code> 看具体情况吧，毕竟 DOM Tree 中的元素没有移除，还不知道该变量是否还会用到。</p>
<blockquote>
<p>如果不再使用，建议 <code>element = null</code>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"more"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handleListener = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="comment">// function handleListener () &#123;</span></span><br><span class="line"><span class="comment">//  console.log(1)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, handleListener)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接解绑</span></span><br><span class="line">element.removeEventListener(<span class="string">'click'</span>, handleListener);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果是一次性的绑定</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"more"</span>)</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//do sth</span></span><br><span class="line">  <span class="keyword">this</span>.removeEventListener(<span class="string">'click'</span>, a)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="如何在页面上查看元素的事件绑定？"><a href="#如何在页面上查看元素的事件绑定？" class="headerlink" title="如何在页面上查看元素的事件绑定？"></a>如何在页面上查看元素的事件绑定？</h4><p>2种方式</p>
<ul>
<li><code>getEventListeners</code> API</li>
<li>控制台查看。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">'a'</span>)</span></span><br><span class="line"><span class="handlebars"><span class="xml">    a.innerHTML = '<span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>点击btn<span class="tag">&lt;/<span class="name">button</span>&gt;</span>'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)</span></span><br><span class="line"><span class="actionscript">    btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'btn'</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="actionscript">    a.addEventListener(<span class="string">'mouseover'</span>, <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'a'</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>通过 <code>getEventListeners</code> API</li>
</ol>
<blockquote>
<p><code>getEventListeners($0)</code>，其中 <code>$0</code> 表示当前选中的页面元素。</p>
</blockquote>
<video controls>
  <source src="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/getEventListener.mp4" type="video/mp4">
  <p>Your browser doesn't support HTML5 video. Here is
     a <a href="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/getEventListener.mp4" target="_blank" rel="noopener">link to the video</a> instead.</p>
</video>

<ol start="2">
<li>控制台查看 Event Listeners 选项</li>
</ol>
<img src="https://crane0.oss-cn-beijing.aliyuncs.com/hexo-blog/006EventListener.jpg" width="450" />

<h3 id="例3，绑定到-window-对象上"><a href="#例3，绑定到-window-对象上" class="headerlink" title="例3，绑定到 window 对象上"></a>例3，绑定到 window 对象上</h3><p>对 <code>window</code> 对象新增属性时，如果是实际需求还好说，如果本意不是如此，那就会有内存泄漏的风险。</p>
<blockquote>
<p>因为 <code>window</code> 是全局对象，新增的属性意味着关闭当前页面才能释放所占内存。</p>
</blockquote>
<ol>
<li>全局调用函数，<a href="https://www.crane0.com/2020/04/20/this指向" target="_blank" rel="noopener">this</a> 指向 <code>window</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'crane0'</span></span><br><span class="line">&#125;</span><br><span class="line">name()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>未使用关键子定义的变量</li>
</ol>
<p>默认也是将 <code>name</code> 变量定义到 <code>window</code> 的属性上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  name = <span class="string">'crane0'</span></span><br><span class="line">&#125;</span><br><span class="line">name()</span><br></pre></td></tr></table></figure>

<h3 id="例4，未销毁的定时器"><a href="#例4，未销毁的定时器" class="headerlink" title="例4，未销毁的定时器"></a>例4，未销毁的定时器</h3><p>定时器不销毁的话，即便定时器函数执行完成不再使用了，定时器和定时器中所依赖的变量也无法回收。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">'crane0'</span> &#125;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> a = obj</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>由于 window.setTimeout 的存在，导致 <code>obj</code> 内存空间始终无法被释放，如果不是业务要求的话，应该在合适的时机使用 clearTimeout 进行清理。</p>
<h3 id="例5，闭包"><a href="#例5，闭包" class="headerlink" title="例5，闭包"></a>例5，闭包</h3><p>闭包使用不当，也容易引起内存泄露。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">'crane0'</span></span><br><span class="line">  <span class="keyword">return</span> inner() &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> inner = foo()</span><br></pre></td></tr></table></figure>

<p>变量 <code>name</code> 将会保存在内存中，直到 <code>inner</code> 不在被引用，<code>name</code>也才会被清除。</p>
<h1 id="解决内存泄露"><a href="#解决内存泄露" class="headerlink" title="解决内存泄露"></a>解决内存泄露</h1><p>在内存泄露的的场景中，已经演示了如何避免内存泄露。</p>
<p>其实不管是基本数据类型，还是引用数据类型的变量，都可以将 <code>null</code> 赋值给它，使改变量的引用次数为 0 即可。</p>
<p>完。</p>
]]></content>
      <categories>
        <category>JavaScript 核心</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>垃圾回收</tag>
        <tag>事件监听</tag>
        <tag>内存泄露</tag>
      </tags>
  </entry>
</search>
